---
title: "\\color{mrgreen}mrg\\color{black}solve: Simulate from ODE-Based Models"
subtitle: "Package vignette to get started simulating"
date: today
abstract: |
  \noindent mrgsolve is an R package for simulation from hierarchical, ordinary
  differential equation (ODE) based models typically employed in drug 
  development. mrgsolve has been used for a wide variety of model 
  applications, including pharmacokinetics (PK), pharmacokinetics/pharmacodynamics 
  (PK/PD), physiologically-based pharmacokinetic (PBPK) modeling, and 
  quantitative systems pharmacology. This vignette provides a comprehensive 
  introduction to using mrgsolve in a single document. While there is more to 
  learn about mrgsolve, this document will give you a good introduction to the 
  essentials and some ideas for thinking about how all the pieces fit together. 
  to help you learn and effectively use mrgsolve. This document was rendered 
  with mrgsolve version **`r packageVersion("mrgsolve")`**. Be sure to visit
  [https://mrgsolve.org](mrgsolve.org) for additional resources.
author: Kyle T. Baron
format: 
  #     - bottom=1.25in
  #     - left=1.0in
  #     - right=1.0in
  #     - top=1.25in
  #     - header.tex
  html: 
    number-sections: true
    toc: true
    toc-depth: 3
    embed-resources: true
    self-contained: true
  mrgsolve_vignette-pdf:
    keep_tex: true
    number-sections: true
    toc: true
    toc-depth: 3
    keywords: rstats, mrgsolve, simulation, ode
  # pdf:
  #   fig-cap-location: bottom
  #   papersize: letter
  #   number-sections: true
  #   toc: true
  #   toc-depth: 2
  #   toc-title: Contents
  #   geometry:
  #   include-in-header:
editor_options: 
  chunk_output_type: console
---


<!-- --- -->
<!-- title: "\\textbf{mrg{\\color{mrgreen}solve}}: Simulate from ODE-Based Models" -->
<!-- subtitle: "Get Started Package Vignette" -->
<!-- shorttitle: "Let's Get Started" -->
<!-- author: Kyle T. Baron -->
<!-- affiliation: Metrum Research Group -->
<!-- keywords: rstats, mrgsolve, simulation, ode -->
<!-- date: 2023-01-04 -->
<!-- format:  -->
  <!-- pdf: -->
  <!--   fig-cap-location: bottom -->
  <!--   papersize: letter -->
  <!--   number-sections: true -->
  <!--   toc: true -->
  <!--   toc-depth: 2 -->
  <!--   toc-title: Contents -->
  <!--   geometry: -->
  <!--     - bottom=1.25in -->
  <!--     - left=1.0in -->
  <!--     - right=1.0in -->
  <!--     - top=1.25in -->
  <!--   include-in-header: -->
  <!--     - header.tex -->

<!-- abstract: | -->
<!--   \noindent mrgsolve is an R package maintained under the auspices of Metrum Research Group that facilitates simulation from models based on systems of ordinary differential equations (ODE) that are typically employed for understanding pharmacokinetics, pharmacodynamics, and systems biology and pharmacology. mrgsolve consists of computer code written in the R and C++ languages, providing an interface to a C++ translation of the lsoda differential equation solver. This vignette will show you how to get started using mrgsolve.  -->
<!--   \newline \newline -->
<!--   **Keywords**: rstats, mrgsolve, simulation, ODE, PK, PKPD, PBPK, QSP -->
<!--   \vskip 0.75cm \hrule -->
<!-- vignette: > -->
<!--   %\VignetteIndexEntry{mrgsolve: Simulate from ODE-Based Models} -->
<!--   %\VignetteKeyword{mrgsolve, r, ode} -->
<!--   %\VignettePackage{mrgsolve} -->
<!-- --- -->
\vskip 0.75cm
\hrule
\vskip 0.5cm

```{=latex}
\setlength{\parindent}{0pt}
```

# Big picture

To start out this package vignette, I want to give you an overhead view of what
it is like working with mrgsolve. There are a _huge_ number of little details
that you might want to eventually know in order to use mrgsolve effectively; but
for now, let's get a handle on the big picture of what you need to do to get 
the simulations you want.

There are 3 (or 4) main simulation workflows that we want to work up to. We can
think about the type of **outputs** we want and _then_ determine what **inputs**
we'll need to create and the **functions** that need to be called in order to
get those outputs back.

First, load the package along with any other helper packages we need for this
vignette.

```{r, message = FALSE, warning = FALSE}
library(mrgsolve)
library(dplyr)
```

## You need a model

For every workflow, you need a model. In most cases, is coded in a separate 
file and read in by `mread()`

```{r}
mod <- mread("azithro-fixed.mod")

mod
```

In the above example, we created a file called `azithro-fixed.mod` (azithromycin
population PK with fixed effect parameters only) and wrote out the covariate
model, differential equations, etc. into that file. We point `mread()` at that
file to parse, compile and load the model. More information on using `mread()`
and the model object is found in @sec-mod. We'll start showing you the model
syntax in @sec-specification.

## Single profile

The first and simplest workflow is to generate a single simulated profile from 
the model. The quickest way we'll do this is using the model object loaded 
in the previous section along with an _event object_

```{r}
#| fig-align: center
mod %>% 
  ev(amt = 250, ii = 24, addl = 4) %>% 
  mrgsim(end = 144, delta = 0.1) %>% 
  plot("CP") 
```

The `mrgsim()` function is called to actually _execute_ the simulation and we've
introduced some simulation options (like the simulation `end` time) by passing 
those arguments in. More info on `mrgsim()` can be found in @sec-simulation. 

The event object is a quick way to introduce an intervention (like dose
administration) into your simulation. More information about event objects is 
provided in @sec-event.

## Population simulation

When we simulate a population, we want to simulate a collection of individuals
(or profiles) in a single simulation run. Most often, this involves creating an 
input data set with dosing or other information for each subject in the 
population.

In this example, we'll load another azithromycin population PK model

```{r}
mod <- mread("azithro.mod")
```

Rather than using an event object as we did for the single profile, we make a 
data set; in this example, we use `expand.ev()` to help

```{r}
set.seed(9876)

data <- expand.evd(amt = 250, WT = runif(10, 50, 100))

data
```

In this data set, we see 10 subjects who are differentiated by their different 
weights (`WT`). For this simulation, we are giving every subject a singe 250 mg
dose.

```{r}
#| fig-align: center
set.seed(9876)

mod %>% 
  data_set(data) %>% 
  mrgsim(end = 24) %>% 
  plot("CP")
```

This simulation introduces variability not only through the covariate `WT` but 
also through random effects (i.e., ETAs) which are simulated when we call 
`mrgsim()`.

## Batch simulation

You can also simulate a population (or a batch of subjects) with a data set of
parameters and an event object. This workflow is _like_ the population
simulation, but the inputs are configured in a slightly different way where
the population is a set of parameters with a common intervention, rather than 
a data set with (possibly) different interventions (or different parameters)
for each subject in the population. Going back to the `azithro-fixed` model

```{r}
mod <- mread("azithro-fixed.mod")
```

Rather than creating a data set with _doses_ for everyone, we just create their
parameters

```{r}
set.seed(9876)

data <- expand.idata(WT = runif(10, 50, 100))

data
```

Here, we have 10 parameter sets which can also be thought of as 10 people.
We can pass this set of parameters as `idata`, or individual-level data, 
along with an event object

```{r}
#| fig-align: center
mod %>% 
  ev(amt = 250, ii = 24, addl = 4) %>% 
  idata_set(data) %>% 
  mrgsim(end = 144) %>% 
  plot("CP")
```

Here, we get the same output as we got for the population simulation, but a 
slightly different setup. This setup might be more or less convenient or more
or less flexible to use compared to the population setup. Either way, the 
approach is up to you and the needs of your simulation project. 

## Replicate simulation

This pattern is just like `data_set`, but we do that in a loop to generate
_replicate_ simulations. Sometimes we do a simulation like this when we are
doing simulation-based model evaluation or maybe we're simulating across draws
from a posterior distribution of parameter estimates.

This simulation might look something like this (code not evaluated in this 
vignette)

```{r}
#| eval: false

sim <- function(i, model, data) {
  mod %>% 
    data_set(data) %>%
    mrgsim() %>% 
    mutate(irep = i)
}

out <- lapply(1:1000, sim, model = mod, data = data) %>% bind_rows()
```

Here, we create a function (`sim()`) that simulates a data set once and then
call that function repeatedly to get replicate simulated data sets.


## The general pattern 

So the general pattern to working with mrgsolve is

- Code a model 
- Load it with `mread()`
- Set up your intervention and population
- Simulate with `mrgsim()`
- Plot or process your output

# Quick start

To quickly get started with mrgsolve, try using the built in model library like
this

```{r, message = FALSE}
mod <- modlib("pk1", delta = 0.1)

out <- mrgsim(mod, events = evd(amt = 100))

out
```

```{r, fig.margin = TRUE}
#| fig-height: 3
#| fig-align: center
plot(out, "CP")
```

That was a really simple simulation where we used an **event object** to initiate
a **dose** into a **one-compartment model** loaded in from an 
**internal library** of pre-coded models. Notice how the `plot()` method allows 
us to quickly visualize what happened in the simulation. See the `?modlib` help 
topic for more models you can play around with to get comfortable with mrgsolve. 
Or keep reading to dig into more of the details on all of the steps presented
in this quick start example. 

# Model object {#sec-mod}

This chapter introduces the mrgsolve ___model object___. The model object 
contains all information about _the model_ itself, including

- Compartments
- ODE
- Algebraic relationships
- Random effects
- More

The model object is what you use in R work with the model, including 

- Query the model
- Run simulations
  
## `mread()`

We saw before that you can load a model from a model specification file using
the `mread()` function. Don't worry for now what is in that file; we'll show you
how to create it in @sec-specification.

### Model file extension {#sec-model-file-extension}

Your model can have any extension. Traditionally, we've used the `.cpp`
extension because a lot of the code in that file is `c++`. However, we've moved
away from that in recent years because code editors like `Rstudio` see that
`.cpp` extension and _think_ that _all_ the code is `c++`; they then format the
code in ways that aren't what you usually want. So using the `.mod` (or `.txt`) 
file extension can be helpful just to keep your editor from doing too much.

### Syntax to load a model 

This section walks you though some of the ways you can use `mread()` to load 
a model.

You can provide the complete path to the file

```{r}
#| eval: false
mod <- mread("model/test.mod")
```


You can provide the file name (first argument) and enclosing directory (as 
`project`); this assumes you are keeping all simulation code in the 
`models` directory

```{r}
#| eval: false
mod <- mread("test.mod", project = "model")
```

This can be a convenient pattern in a larger project because the `project` 
argument can be pulled from the `mrgsolve.project` R option (see `?options`).
For example

```{r}
#| eval: false
options(mrgsolve.project = "model")

mod <- mread("test.mod")
```

### Update the model on load

mrgsolve provides an `update()` method for changing some settings inside a model
object. `mread()` will take in arguments and pass them along to `update()` so
you can make these changes at the time the model is loaded. For example, 
we can 

- Set the simulation end time to `240`
- Set (increase) ODE solver relative tolerance to `1e-5`

by passing the appropriate arguments through `mread()`

```{r}
#| eval: false
mod <- mread("model/test.mod", end = 240, rtol = 1e-5)
```

### Read and cache

Use `mread_cache()` to build and cache the model on disk. 

When you load the model the first time, you'll see

```{r}
mod <- mread_cache("test.mod", project = "model")
```

When you load it again, you'll see

```{r}
mod <- mread_cache("test.mod", project = "model")
```

By default, mrgsolve will store the cached model information in the temporary
directory that R sets up every time you start a new R session. This is
convenient because you don't have to think about what that directory is, but
sometimes you want the cached model to sit in a location that you have a little
more control over. Look at the `soloc` argument to `mread()`; this will let you
place the cached model information in a stable location.

## `modlib()`

Use the `modlib()` function to load a model from an internal model library.
These are pre-coded models that can be sourced from within the mrgsolve 
installation directory. They are a great way to get your hands on different
models to experiment with. But note: I rarely use these for production work; 
_almost_ always, my production model is more complicated that what has been 
coded into these general-purpose library models.

This code will load a 1-compartment PK model 

```{r}
#| eval: false
mod <- modlib("pk1")
```
 
So the `modlib()` function is equivalent to 

```{r}
#| eval: false
mod <- mread("pk1", project = modlib())
```

Check out the `modlib()` help topic for a more detailed listing of the models

```{r}
#| eval: false
?modlib
```

## Model overview

You can print `mod` to the R console and see what's going on 

```{r}
mod
```

or summarize

```{r}
summary(mod)
```

or see the model code

```{r}
see(mod)
```


## Parameters

Parameters are `name=value` pairs that are used in your model. You can _change_
the `value` of a parameter in several different ways. Understanding how 
to do this parameter value update is really important if you want to make 
interesting simulation outputs.

Query the parameter list with `param()`

```{r}
param(mod)
```

This output shows you there are 3 parameters in the model 

- `CL`, with nominal value 1
- `V`, with nominal value 20
- `KA`, with nominal value 1

Note that each parameter has

- A **name**(e.g. `CL`)
- A **value** (must be _numeric_ or _evaluate_ to a numeric value) 

Parameter names can be upper or lower case letters or numbers; the only 
punctuation allowed in parameter names is underscore (`_`).

Parameters are unordered; the order in which you code the parameters makes no 
difference to how you are able to work with the model.

See @sec-parameters for a deeper discussion of model parameters and their central
role in generating simulations to answer questions at hand.

## Compartments

Models also have compartments. Like parameters, compartments have 

- A **name**
- A **value** 

The same rules hold for compartment names that we discussed for parameter 
names. 

Compartments also have a ___number___; they are numbered in the order in which
they are entered. 

Query the compartment list with `init()`. For example, using the model we loaded
in the previous section

```{r}
init(mod)
```

Notice that each compartment has a number associated with it; this is mainly
used for dosing via `CMT` in your data set. But there is a model syntax that
allows you to write a model in terms of named compartments (e.g. `A(2)` or `F1`)
as well.

## Random effects

You can see what random effect matrices are available in the model with

```{r}
revar(mod)
```


## Update the model object {#sec-update}

We frequently want to _change_ or _update_ the settings in the model object. 

Updates can be made through the `update()` method. For example, use

```{r}
mod <- update(mod, end = 240, delta = 2)
```

to change the simulation end time to `240` hours and the output time interval
to every 2 hours. This results in a new model object with updated settings that 
will be in place whenever you simulate from `mod` until you make more changes. 

You can also update on model read

```{r}
#| eval: false
mod <- mread("model.mod", end = 240, delta = 2)
```

or at the time of simulation 

```{r}
#| eval: false
out <- mod %>% mrgsim(end = 240, delta = 2)
```

All of these update mechanisms execute updates to the model object. But only 
when we save the results back to `mod` are the updates persistent in the model.

__What else can I update?__

- Time
  - `start`, `end`, `delta`, `add`
- Parameters and compartment initial values
- ODE solver settings
  -  `atol`, `rtol`
  -  `hmax`, `maxsteps`, `mxhnil`, `ixpr`
  - Usually changing `rtol`, `atol`, and maybe `hmax`
- Settings related to steady state
  - `ss_rtol`, `ss_atol`
- `$OMEGA`, `$SIGMA`
- `tscale` (rescale the output time)
- `digits`
- `outvars` (which compartments or derived quantities should appear in the 
   output)

See `?mrgsolve::update` for more details.

__Parameter update__

To update parameters, use `param()`. More on this in @sec-parameters 

```{r}
#| eval: false
mod <- param(mod, CL = 2)
```

## Write a model object to file

Recall that we use `mread()` or `mread_cache()` to read model code from a file 
into an object in your R session. mrgsolve also allows you to write the model 
contents out to a file again. The code in the new file will be well formatted, 
but it will be by necessity different in some ways from the code you originally
wrote.

As an example, read `test.mod` back into R

```{r}
mod <- mread_cache("model/test.mod")
```

We can update this model 

```{r}
mod <- update(mod, end = 240, delta = 6, rtol = 1e-4)
mod <- param(mod, V = 15, CL = 1.5)
```

We can write this model back to file in a couple of different formats. First, 
you can write it in `yaml` format with `mwrite_yaml()`

```{r}
file <- mwrite_yaml(mod, file = "model/test.yaml")
```

Now the model code has been written back to the file `test.yaml` in the `model`
directory.

There is no requirements for file extension; we just chose `yaml` to match the 
format. 

To read this file back into R, use `mread_yaml()`

```{r}
mod2 <- mread_yaml("model/test.yaml") 
```

Now, you have a model you can simulate from again (`mod2`). 

You can also write the model out in native mrgsolve format

```{r}
mwrite_cpp(mod2, file = "model/test-3.cpp")
```

Of course, we can read this file back in using `mread()` and 
friends. 

The important feature of `mwrite_*` is that it breaks any connections to NONMEM 
outputs that might be created through the use of `$NMXML` or `$NMEXT` blocks.

For example, model `1005` in `modlib()` is connected to a NONMEM model

```{r}
modx <- modlib("1005")

as.list(modx)$nm_import
```

This mrgsolve model is reading `THETA`, `OMEGA` and `SIGMA` from 
`1005.xml`. 

When we write the code to, for example, `yaml` format, all parameters
and matrices are written into the file as they are, forgetting they 
came from the NONMEM run.

```{r}
tmp <- tempfile()
mwrite_yaml(modx, file = tmp)
```

We can check that this is true by parsing the yaml file

```{r}
y <- yaml::yaml.load_file(tmp)

names(y)

y$param[1:5]
```

This functionality can be very helpful when sharing your NONMEM-backed
simulation model written in mrgsolve. 


## Advanced

This section shows some advanced methods for interacting with the mrgsolve 
model object.

__Get the value of a parameter or setting__

```{r}
mod$CL
mod$end
```

__Extract all parameters as a list__

```{r}
as.list(param(mod))
```

Extract the value of one parameter

```{r}
mod$CL
```

__Extract everything__

You can get the model object contents as a plain list

```{r}
l <- as.list(mod)
```


# Event objects {#sec-event}

Event objects are quick ways to generate an intervention or a sequence of
interventions to apply to your model. For example, you have a PK model and want
to implement a series of doses into the system during the simulation. Event 
objects function like quick and easy data sets to accomplish this.


## Create an event object

Use `ev()` and pass NMTRAN data names in lower case. 

For example

```{r}
ev(amt = 100, ii = 12, addl = 2)
```

You can pass

- `time` time of the event
- `evid` event ID
  - 1 for dose
  - 2 for other type
  - 3 for reset
  - 4 for dose and reset
  - 8 for replace
- `amt` dose amount
- `cmt` compartment for the intervention
  - usually the compartment number
  - can be character compartment name
- `ii` inter-dose interval
- `addl` additional doses (or events)
  - `total` alternative for total number of doses
- `ss` advance to steady-state?
  - 0 don't advance to steady-state
  - 1 advance to steady-state
  - 2 irregular steady-state
- `rate` give the dose zero-order with this rate
  - `tinf` alternative for infusion time 
- other `name=value` items that you would like to appear in the data set
  underlying the simulation


See `?ev` for additional details. 

## Invoke event object

There are several ways to create an invoke event objects. 

### Inline

When the event is simple and can be expressed in a single line, you can pipe
the model object to `ev()` and then simulate.

```{r}
#| fig-height: 3
#| fig-align: center
mod <- house(outvars = "GUT,CP,RESP", end = 24)

mod %>% ev(amt = 100) %>% mrgsim() %>% plot()
```

This is a common workflow when exploring a model and an intervention.


### As object

You can also save the event object and pass it into the pipeline as we did 
before with the inline setup. 

```{r, eval = FALSE}
#| fig-align: center
e <- ev(amt = 100) 

mod %>% ev(e) %>% mrgsim() %>% plot()
```

Invoking the event object this way is a good idea when you want to create an
intervention and apply it to several different simulation scenarios in the same
script.

Alternatively, you can pass it in as the `events` argument for `mrgsim()`.

```{r, eval = FALSE}
#| fig-align: center
mod %>% mrgsim(events = e) %>% plot()
```

This is functionally the same as passing the (saved) event object into the 
pipeline via `ev()`.

## Combining event objects 

We can create more complex interventions from several, simpler event objects. 
mrgsolve provides an interface with helper functions to facilitate this.

### Simple combination

Use the `c()` operator to concatenate several event objects into a single event
object.

For 100 mg loading dose followed by 50 mg daily x6

```{r}
load <- ev(amt = 100) 

maintenance <- ev(time = 24, amt = 50, ii = 24, addl = 5)

dose <- c(load, maintenance)

dose
```

The final event object has all the simpler event object smashed together, with 
no modification. 

### Sequence

We can make this simpler by putting these in a sequence using the `seq()` 
generic.  Here is 100 mg daily for a week, followed by 50 mg daily for the rest 
of the month

```{r}
a <- ev(amt = 100, ii = 24, total =  7) 
b <- ev(amt = 50,  ii = 24, total = 21)

seq(a, b)
```

The output shows that the `b` event was automatically timed to start once all of
the doses from the `a` event were given.

You can also put a waiting period in between event objects in a sequence; to 
wait for 7 days between `a` and `b` from the example above

```{r}
seq(a, wait = 24*7, b)
```
Now, `b` starts one week after `a` ends.


### Expand into multiple subjects

We can take any event object and replicate it into several subjects with the 
`ev_rep()` function. 

```{r}
seq(a,b)

seq(a,b) %>% ev_rep(1:3)
```


### Combine into a data set

Use `as_data_set` with `ev_rep()` to create a single data set

```{r}
c <- seq(a,b) 

as_data_set(
  a %>% ev_rep(1:2), 
  b %>% ev_rep(1:2), 
  c %>% ev_rep(1:2)
)
```
This example gives us two subjects receiving 100 mg for a week, two subjects
receiving 50 mg for 3 weeks, and two subjects receiving 100 mg for a week
followed by 50 mg for 3 weeks.


## Modifying event objects

You can use a selection of the tidyverse to modify event objects. For example,

```{r}
single <- ev(amt = 100) 

ss <- mutate(single, ii = 24, ss = 1)  

ss
```

Available tidyverse verbs for working on event objects include

- `mutate()`
- `select()`
- `filter()`


## Column name case

By default, event objects have lower case names when they are rendered to 
a data frame or a data set

```{r}
ev(amt = 100) %>% as.data.frame()

ev(amt = 100) %>% as_data_set()
```

You can request upper case names by using the `evd()` constructor

```{r}
evd(amt = 100) %>% as.data.frame()
```

These are the names you will see in the rendered data set and in the simulated
output. Equivalent behavior is seen with 

```{r, eval = FALSE}
evd_expand(amt = 100)
expand.evd(amt = 100)
```


Note that, when working with event objects, always refer to lower case names

```{r}
e <- evd(amt = 100)
e <- mutate(e, ss = 1)
as.data.frame(e)
```

You can change the case of any event object _to_ upper case (`uctran()`) or 
_to_ lower case (`lctran()`)

```{r}
evd(amt = 100) %>% as.data.frame() %>% lctran()
```

In this example, we created an event object using `evd()` and then immediately 
requested lower case names. This step can also be performed on a raw data 
frame as well. 


## Rx specification

This is an alternate syntax letting you create event objects the same way you 
might write out a prescription. 

```{r}
ev_rx("100 mg x1 then 50 q12h x 10 at 24")
```

This syntax will cover many common dosing scenarios. But more complicated 
scenarios might require creating events as usual with `ev()` and then combining
as described above. 

# Data sets

A "data set" is just a data frame with time, dose, and covariate information for
one or more subjects in a population. You can make data frame any way you want,
as long as the result meets a couple of requirements. That said, mrgsolve
contains some convenient functions to make it easier to create these data
frames. A data set is a more general form of the event objects you read about in
@sec-event, so it might help to review that section now if you haven't already.

## Requirements

There are some requirements for input data sets. 

- Only numeric data can get passed into a problem; mrgsolve will quietly remove 
  any non-numeric columns before simulating

- Like event objects, NMTRAN data columns can be in upper or lower case, but not 
  both (pick `AMT/CMT/TIME` or `amt/cmt/time`, not `AMT/cmt/TIME`)
  
- Also like event objects, you can switch between upper and lower case naming
  with `lctran()` and `uctran()`

- Must contain the columns `ID`, `TIME/time`, `CMT/cmt`, `EVID/evid`

- If you have a column with the same name as a parameter in your model, that
  column cannot contain missing values (`NA`; see @sec-parameters)

- mrgsolve recognizes a "new" ID in the data set when the value of `ID` changes
  from record to record; however, we recommend using unique ID numbers for 
  subjects in a data set

## Connection with event objects

There is a natural connection between event objects and data sets: we made
event objects to work the way they do so it would be easy to create data sets
from them. So, if I have an event object specifying only a single dose

```{r}
e <- evd(amt = 100)
e
```

we can render that into a data set and it will be configured to meet all the 
requirements

```{r}
data <- as_data_set(e)
data
```

Here, I didn't specify some required items (like `TIME`), but mrgsolve filled
them in with something sensible. 

Notice that, in this example, `e` is an event object

```{r}
class(e)
```

but `data` is just a plain old data frame

```{r}
class(data)
```

## Multiple subjects in a data set {#sec-data-multiple-subjects}

Data sets commonly contain information for more than one subject. There is no 
practical limit to the complexity you can code into the data set for any given
individual: one subject might have a single dose whereas another subject may 
have many doses; doses can be given by different routes; doses may or may not 
be at steady state etc. 

For example, it's not a problem to have this mix up of dosing scenarios in a 
single data set:

```{r}
#| echo: false
e1 <- evd(amt = 100) 
e2 <- ev(amt = 200, rate = 50, ii = 24, addl = 3) 
e3a <- ev(amt = 50, ii = 12, ss = 1, addl = 3)
e3b <- ev(amt = 100, ii = 24, addl = 2)
e3c <- ev(amt = 200, ii = 48, addl = 2)
e3 <- ev_seq(e3a, e3b, e3c)

data <- as_data_set(
  e1 %>% ev_rep(1:3), 
  e2, 
  e3 %>% ev_rep(1:2)
)
data_example <- data
data
```

## Creating data sets

mrgsolve provides some convenience functions you can use; we've found them
helpful when certain input data sets are needed. 

### `ev_rep()`

One common way to make a data set is to replicate an event object. We can take
a very simple event object

```{r}
e <- ev(amt = 100)
```

and replicate it to create several subjects with that dose. To create 3 
subjects, call


```{r}
ev_rep(e, 1:3)
```

Notice that `ev_rep()` converts the event object into a data frame / data set. 
This function can be convenient when the input event object is complicated like
this

```{r}
e1 <- evd(amt = 100, ii = 24, addl = 5)
e2 <- evd(amt = 200, ii = 12, addl = 6)
e3 <- evd(amt = 50, rate = 25)

e <- ev_seq(e1, e2, e3)
e
```
It's easy to replicate this into a data set of 3 (or 300) subjects
```{r}
ev_rep(e, 1:3)
```

### `as_data_set()`

Alternatively, we can use `ev_rep()` to replicate each event object and then
combine them all into a single data frame with `as_data_set()` 

```{r}
as_data_set(ev_rep(e1, 1:2), ev_rep(e, 1:2))
```
`as_data_set()` combines these event objects together and ensures there are 
unique values for each `ID` while maintain the complexity within each 
subject. 

### `ev_expand()`

The `ev_expand()` function will create a single data frame / data set for 
many subjects, but each subject has a single dosing record. The `_expand`
part of the function name indicates that we create all combinations of inputs. 
For example, we can have 3 individuals at each of 2 doses

```{r}
ev_expand(ID = 1:3, AMT = c(200, 400))
```

Notice that `ID` runs from 1 to 6 and each `ID` appears only on one row. You 
might see another function called `expand.ev()`; it does the same thing, but 
is named to mimic its base R cousin called `expand.grid()`.

### See the user guide

See the mrgsolve [user guide](https://mrgsolve.org/user-guide/datasets.html) 
for more functions you can use to create interesting input data sets. But 
remember that you don't _have_ to use our convenience functions; you might be 
better off coding your own to get the inputs you need for your simulation.

## What about observation records?

You'll notice our input data sets only include dosing records. When this is the
case, mrgsolve will fill in the observation records for you according to the
internal simulation time grid maintained in the model object (@sec-update). You
can put observation records into the data set and get exactly the sampling
scheme you want for each subject; this is how we simulate from clinical data
sets (e.g. those you might use in model development). So this is possible and
you might do it. But most of the time when you are simulating _de novo_, you
should let mrgsolve fill in the observation records. More on this in the [user
guide](https://mrgsolve.org/user-guide/datasets.html).

## Invoking data sets

Once you have a model your data set is created, you can pass it into a 
simulation pipeline with the `data_set()` function. Simulating from the 
data set we showed in @sec-data-multiple-subjects with an example population
PK model from the internal library ("popex"): 


```{r}
#| echo: false
data <- data_example
```

```{r}
mod <- modlib("popex", delta = 0.1, end = 300)

set.seed(2468)
mod %>% 
  data_set(data) %>%
  mrgsim(recsort = 3) %>% 
  plot(IPRED ~ time|factor(ID))
```

Alternatively, you can just pass the data set to `mrgsim()`

```{r}
#| eval: false
mod %>% mrgsim(data = data)
```

# Simulation and outputs {#sec-simulation}

This section discusses

- Simulation from a model object
- Dealing with simulated output


## `mrgsim()`

Use the `mrgsim()` function to actually run the simulation. We always pass in 
the model object as the first argument. 

```{r}
#| message: false
mod <- modlib("pk1") %>% ev(amt = 100)
```

```{r}
mrgsim(mod)
```

Alternatively, we can execute the simulation by passing the model object in 
with the pipe

```{r}
#| fig-align: center
#| fig.height: 3.5
mod %>% mrgsim() %>% plot()
```

### Update

The `mrgsim()` signature contains `...` which are passed to `update()`. Use 
this mechanism to customize your simulation or the output on the fly

```{r}
#| fig-height: 3
#| fig-align: center
mod %>% mrgsim(outvars = "CP", end = 72, delta = 0.1) %>% plot()
```

In this example, we selected the output variable (`CP`), ran the simulation
to 72 hours (`end = 72`) and asked for a finer output time grid (`delta = 0.1`).

### Options

There are some options that can _only_ be set when you call `mrgsim()`. These
are function arguments; you can see them at `?mrgsim`.

- `carry_out`: numeric data columns to _copy_ into the simulated output
- `recover`: like `carry_out` but works with any type
- `output`: pass `"df"` to get output as a regular data frame
- `obsonly`: don't return dosing records in the simulated output
- `etasrc`: should ETAs be simulated? or scraped from the data set
- `recsort`: how doses and observations having the same time are ordered
- `tad`: insert time after dose into the output
- `ss_n` and `ss_fixed`: settings for finding steady state
- `nocb`: next observation carry backward; set to `FALSE` for locf


### Variants

__Inputs__

There are `mrgsim()` variants which are specific to the types of inputs

- `mrgsim_e()` - just an event object
- `mrgsim_d()` - just a data set
- `mrgsim_ei()` - event + idata set
- `mrgsim_di()` - data set + idata set
- `mrgsim_i()` - just idata set


__Outputs__

You can also call `mrgsim_df()`, which is a wrapper for `mrgsim()` that 
always returns a data frame. 


__Quick__

Call `mrgsim_q()` for a quick turnaround simulation, with minimal overhead (and
features). This is only really useful when you are simulating repeatedly, many
100s or 1000s of times or more ... like when estimating parameters or doing
optimal design. These functions will not make a single simulation run much 
faster and they won't turn a long-running simulation into a short-running 
simulation.

## Simulated output

`mrgsim()` returns an object with class `mrgsims`; this is essentially a data 
frame but with some  extra features.

```{r}
out <- mrgsim(mod)

class(out)

head(out)

summary(out)
```

### Output scope

The first column in the  simulated output is always `ID`. The second column in 
the output is always `time` (or `TIME`).

By default, you get simulated values in all compartments and for every 
derived output _at every_ time

```{r}
head(out)
```

- `EV` and `CENT` are compartments
- `CP` is a derived variable (`CENT/V`)


We can use the `outvars()` function to look at what compartments and derived
variables will come back in the simulation

```{r}
outvars(mod)
```

You can control which compartments and derived outputs are returned when 
you do a simulation run. This is a _really_ important feature when the 
simulations become very large: limiting the outputs to those you actually need
can make the difference between a simulation that fits within the available
memory and one that doesn't.

To request specific outputs at simulation time, set `outvars` in the model
object. In this example, we make the selection on the fly

```{r}
mod %>% 
  update(outvars = "CP") %>% 
  mrgsim()
```

Alternatively, we can make the change persistent

```{r}
mod2 <- update(mod, outvars = "CP")

outvars(mod2)
```

### Copy inputs into output

Input data items can be _copied_ into the simulated output without passing 
through the model c++ code itself. 

For most applications, use the `recover` argument to `mrgsim()`. 

```{r}
data <- expand.ev(amt = c(100, 300))

data <- mutate(
  data, 
  dose = amt, 
  arm = case_match(
    dose, 
    100 ~ "100 mg x1", 
    300 ~ "300 mg x1"
  )
)

out <- mrgsim(mod, data, recover = "dose, arm", output = "df")

count(out, dose, arm)
```

This will let you copy inputs of _any type_ into the output (for example, 
character or factor data). 

If you just want to get numeric inputs into the output, use `carry_out`

```{r}
data <- expand.ev(amt = c(100, 300)) %>% mutate(dose = amt)

out <- mrgsim(mod, data, carry_out = "dose", output = "df")

count(out, dose)
```


## Working with `mrgsims` object

The `mrgsims` object can be convenient to work with when the output is small. 

```{r}
mod <- modlib("pk1", delta = 0.1)

out <- mrgsim(mod, ev(amt = 100))
```


```{r}
out
```

### Plot

The main benefit from using this object is the ability to easily make plots
to see what happened in the simulation. You can plot a single output

```{r}
#| fig-height: 3
#| fig-align: center
plot(out, CP ~ time)
```

or a collection of outputs

```{r}
#| fig-height: 3
#| fig-align: center
plot(out, "CP CENT")
```


### Filter

Use `filter_sims()` to limit the rows that are retained in the simulated output

```{r}
#| fig-align: center
#| fig-height: 3.5
out2 <- filter_sims(out, time <= 5)

plot(out2)
```

### Mutate

Use `mutate_sims()` to alter the columns in the simulated output

```{r}
mutate_sims(out, week = time/168)
```


## Coerce output

When output is big, the methods mentioned above are less likely to be useful:
what we really want is just a simple data frame to work on. In this case, 
coerce outputs to data.frame or tibble


```{r}
df <- as.data.frame(out)
df <- as_tibble(out)
head(df)
```

Once the output is coerced to data frame, it is like any other R data frame. 

Remember that you can get a data frame directly back from `mrgsim()` with 
the `output` argument

```{r}
mrgsim(mod, ev(amt = 100), output = "df") %>% class()
```

This is what you'll want to do most of the time when doing larger simulations.


### dplyr verbs

You can pipe simulated output directly to several dplyr verbs, for example
`filter()` or `mutate()`. 

```{r}
mod %>% mrgsim(ev(amt = 100)) %>% mutate(rep = 1)
```

This will first coerce the output object to a data frame and then continue
to work on the simulated data according to the functions in the pipeline.

Other verbs you can use on an `mrgsims` object include

- `group_by()`
- `mutate()`
- `filter()`
- `summarise()`
- `select()`
- `slice()`
- `pull()`
- `distinct()`


# Model parameters {#sec-parameters}

```{r}
#| include: false
data <- expand.grid(
  WT = c(60, 70, 80), 
  SEX = 0, 
  EGFR = 60
)
data <- mutate(
  data, 
  ID = row_number(), 
  TIME = 0,
  AMT = 100, 
  CMT = 1, 
  EVID = 1
) %>% select(ID, TIME, AMT, CMT, everything())
write.csv(
  x = data, 
  file = "parameters-data.csv", 
  quote = FALSE, row.names = FALSE
)
```


Model parameters are `name` / `value` pairs that are used _inside_ your model, 
but they can be varied _outside_ the model. 

Understanding how mrgsolve handles model "parameters" particularly important 
for generating interesting and robust simulations. 

Big picture

- `mrgsolve` maintains a parameter list, including parameter names and values
  - The parameter list is set at the time the model is compiled; names and 
    number of parameters cannot be changed after compile time
  - This list is used by default if nothing else is done
  - The parameter values in this list can be updated

- `mrgsolve` will check input data sets for _columns_ which have the same 
  name as a parameter
  - When a match is made between data set and parameter list, `mrgsolve`
    will update the value based on what is passed on the data
  - Parameters in `idata` are checked (and parameter list  updated) first; 
    after that, the data set is checked (and parameter list updated)

## Coding model parameters

Traditionally, we've used the `$PARAM` block to set parameter names and values

```{r, eval = FALSE}
$PARAM 
WT = 70, SEX = 0, EGFR = 100
```

New in mrgsolve 1.2.0, you can use the `$INPUT` block. This is another way
to specify parameters, but they will have a special _tag_ on them that we can 
use later. 

```{r, eval = FALSE}
$INPUT 
WT = 70, SEX = 0, EGFR = 100
```

It's best if you can set these to sensible values; this is usually the
_reference_ value in your covariate model or some other value that gives you 
a sensible _default_ output.

## Updating parameter values

You can't change the names or number of parameters after you compile the model, 
but you can change the values. You can update parameters either 

- _prior to_ simulation or 
- _during_ simulation

We will illustrate with this model

```{r}
mod <- mread("parameters.mod")
```

```{r}
param(mod)
```

There parameters are: 

- `WT`
- `SEX`
- `EGFR`
- `THETA1` ... `THETA5`

### Update _prior to_  simulation

Use `param()` to update the model object. You can do this in one of two ways. 

#### Update with `name=value`

The first way is to pass the new value with the parameter name you want to 
change. To change `WT`


```{r}
mod$WT
```

```{r}
mod <- param(mod, WT = 80)

mod$WT
```

And when we simulate, 

```{r}
#| fig-align: center
mrgsim_df(mod) %>% count(WT)
```

You can also do this via `update()`

```{r}
mod <- update(mod, param = list(WT = 60))

mod$WT
```

Remember that `mrgsim()` passes to `update()` so you can do the same thing
with 

```{r}
#| eval: false
out <- mrgsim(mod, param = list(WT = 70))
```

This will generate simulated output with `WT` set to 70.

### Update with object

If you have a named object, you can pass that in to the update as well. For
example, pass in a named list

```{r}
p <- list(WT = 70.2, FOO = 1)

mod <- param(mod, p)

mod$WT
```

Or a data frame

```{r}
data <- data.frame(WT = c(70, 80.1), BAR = 2)

mod <- param(mod, data[2,])

mod$WT
```


## Update _during_  simulation 

In this approach, we'll add a columns to our input data set with the same names
as our parameters and let `mrgsolve` pick up the new values. To illustrate, load
a data set from which to simulate

```{r}
data <- read.csv("parameters-data.csv")
data
```

In this data set, subjects 1, 2, and 3 have different (increasing) weight; all
subjects have `SEX=0` and `EGFR=60`. When we pass this data frame for simulation
and plot

```{r}
#| fig-align: center
out <- 
  mod %>% 
  data_set(data) %>%
  zero_re() %>% 
  mrgsim(delta = 0.1, end = 6)

plot(out, "WT,CP")
```

All of this _only_ works if the names in the data set match up with the names 
in the model. 

## Check if the names match

Recall that we coded the model covariates using `$INPUT`, rather than `$PARAM`?
We can see that these parameters have this special tag

```{r}
param_tags(mod)
```

They have the `input` tag, which means we expect to find them on the data set
_when we ask_. We can check this data set against the parameters in the model

```{r}
check_data_names(data, mod)
```

Now, modify the data set so it has `eGFR` rather than `EGFR`

```{r}
data2 <- rename(data, eGFR = EGFR)

check_data_names(data2, mod)
```

See the `mode` argument to `check_data_names()`; you can warn or inform the 
user in case parameter names don't look right, or you can issue an error.

# Model Specification {#sec-specification}

This chapter gives a broad overview of mrgsolve model specification syntax.
We'll start by coding up a pharmacokinetic model. The model will be very simple
to start, letting us get some concepts in place. Later on, we'll do more
complicated model syntax.


![](pk-model.png)


The model parameters are

- `CL`
- `V`
- `KA`

The model compartments are

- `CENT`
- `DEPOT`


## Model specification blocks

Model components are coded into blocks, which are delineated by a 
specific block syntax. You have a couple of options

__NONMEM style__

These start with `$` and then the block name (`$PK`)

__Bracket style__

Put the block name in brackets (`[ ERROR ]`)

__Upper or lower case__

You can use either:

- `$error`
- `[ pk ]`
- `[ DES ]`

etc ... they all work.


### Syntax

The "type" of code you write will vary from block to block. 
Sometimes it is an R-like syntax and sometimes it is 
`c++` code. 

Don't worry if you don't know `c++`! We have taken a lot of 
the complexity out and with a handful of exceptions, the 
code should be pretty natural and similar to what you write
in R. 

## Base model blocks

### Parameters

Use the `$PARAM` block header.

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1
```

Parameters have a **name** and a **value**, separated by `=`.

Parameter names can be upper or lower case. If you want punctuation, 
use underscore `_`.

Parameter values must _evaluate_ to a numeric value.

Parameters can't be functions of other parameters 
_when writing the `$PARAM` block_. But there is a place where you can do 
this ...we'll see this later on.

Multiple parameters can go on one line, but separate by comma.

### Read it in with `mread()`

Point `mread()` at your model file to read it in and see if it compiles.

```{r}
mod <- mread("simple.mod")
```

We suggest writing the model in small sections, interactively checking to see if 
the model compiles. When you find syntax mistakes (you _will_ find them), they 
will be easier to fix this way. 


## Compartments

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT
```

Compartments are named 

- Upper or lower case
- Punctuation use `_`

Order doesn't matter, but consider listing your default dosing compartment 
first. This is a convenient pattern to keep so you can just dose into 
compartment 1 when setting up your data set or event object. 


## Differential equations

Now, we'll write ODE using `$DES` (or `$ODE`) block. 

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT

$DES
dxdt_DEPOT = -KA * DEPOT;
dxdt_CENT  =  KA * DEPOT - (CL/V)*CENT;
```

Left hand side is `dxdt_<compartment name>`. 

Right hand side can reference

- Compartments
- Parameters
- Other quantities derived in `$DES` or `$PK`
- Other internal variables

Unlike `$PARAM` and `$CMT`, this is `c++` code; you can include any valid `c++`
statement. Also, because this is `c++`, each line or statement should end in 
semi-color (`;`).

## Derived outputs

Like NONMEM, derived can be calculated in the `$ERROR` block.

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT

$DES
dxdt_DEPOT = -KA * DEPOT;
dxdt_CENT  =  KA * DEPOT - (CL/V)*CENT;

$ERROR
double CP = CENT/V;
```

Like `$DES`, this block must be valid `c++` code. 

Here we have created a new variable called `CP`, which is the amount in the
central compartment divided by the central volume of distribution.

When we create a new variable, we must declare its `type`. Use `double` for a
floating point number.

## Capture outputs into the simulated data

mrgsolve has a `$CAPTURE` block that works like NONMEM's `$TABLE`. Just list the
names you want copied into the output.

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT

$DES
dxdt_DEPOT = -KA * DEPOT;
dxdt_CENT  =  KA * DEPOT - (CL/V)*CENT;

$ERROR
double CP = CENT/V;

$CAPTURE CP
```

Rather than putting stuff in `$CAPTURE`, try declaring with type `capture`

```{r, eval = FALSE}
$ERROR
capture CP = CENT/V;
```

`capture` is identical to type `double`, but tells mrgsolve to include this 
item in the simulated output.

A little-use feature is renaming items in `$CAPTURE`

```{r}
#| eval: false
$ERROR 
double DV = CENT/V;

$CAPTURE CP = DV
```

The syntax is `<new-name> = <old-name>`. 


## Covariate model

Like NONMEM, we can use `$PK` (or `$MAIN`) to code the covariate model, 
random effects, F, D, R, and ALAG, and initialize compartments. 

```{r}
#| eval: false
$PK

double CL = TVCL * pow(WT/70, 0.75) * exp(ETA(1));
```

- Any valid `c++` code is allowed
- Each line (statement) should end in semi-colon `;`


## C++ examples

You can find all sorts of help with `c++` syntax on the web. Here are a few 
common bits of `c++` code that you might need in your model. 

```{c, eval=FALSE}
if(a == 2) b = 2;
if(b <= 2) {
  c=3;
} else {
  c=4;
}
d = a==2 ? 50 : 100;
double d = pow(base,exponent);
double e = exp(3);
double f = fabs(-4);
double g = sqrt(5);
double h = log(6);
double i = log10(7);
double j = floor(4.2);
double k = ceil(4.2);
```

### Integer division

Be careful of dividing two integers; it's usually not what you want to do. When 
people get bit by this, it's usually when they divide one integer literal
by another integer literal in their code. For example, we might _think_ the 
following should evaluate to `0.75`

```{r}
#| eval: false
double result = 3/4; # 0
```

but it doesn't. Here, `result` will evaluate to `0` because the `c++` compiler
will do integer division between the 3 and the 4 and you'll get `0`. 

It is good to get in the habit of putting `.0` behind whole numbers. 

```{r}
#| eval: false
double result = 3.0/4.0; # 0.75
```

Of course, you _might_ really want to divide two integers at some point; but 
for now, please mind this "feature" of `c++` when writing your code. 


## Random effects

There are times when you _will_ need to code this manually. When estimating
with NONMEM and simulating with mrgsolve, these matrices will 
frequently be imported automatically via `$NMXML` or `$NMEXT`.

### Omega / ETA

**Diagonal matrix**

```{r}
#| eval: false
$OMEGA
0.1 0.2 0.3
```

This is a 3x3 matrix with 0.1, 0.2, and 0.3 on the diagonal.

**Block matrix**

```{r}
#| eval: false
$OMEGA @block
0.1 0.002 0.3
```

This is a 2x2 matrix matrix with 0.1 and 0.3 on the diagonal. Sometimes it's 
easier to see when we code it like this

```{r}
#| eval: false
$OMEGA @block
0.1 
0.002 0.3
```

Random effects simulated from OMEGA are referred to with `ETA(n)`.

### Sigma / EPS

Works just like Omega / ETA, but use `$SIGMA` and `EPS(n)`.

For sigma-like theta, code it just as you would in NONMEM. 

```{r}
#| eval: false
$PARAM THETA12 = 0.025

$SIGMA 1

$ERROR
double W = sqrt(THETA12);
Y = (CENT/V) + W*EPS(1);
```

There is no `FIX` in `mrgsolve`; everything in OMEGA and SIGMA is always fixed. 

## Import estimates from NONMEM

- Use `$NMEXT` or `$NMXML`
  - `$NMEXT` reads from the `.ext` file
    - Can be faster than `$NMXML` when the `root.xml` file gets big
    - Doesn't retain `$OMEGA` and `$SIGMA` structure
  - `$NMXML` reads from the `.xml` file
    - Can be slower than `$NMEXT`
    - Does retain `$OMEGA` and `$SIGMA` structure

This is the safest way to call

```{r}
#| eval: false
$NMXML
path = "../nonmem/106/106.xml"
root = "cppfile"
```

You might be able to use this `run`/`project` approach as well

```{r}
#| eval: false
$NMXML 
run = 1006
project = "../sim/"
root = "cppfile"
```

This code will look for `1006/1006.xml` under `sim`, one directory level up 
from the location of the mrgsolve "cpp` file. 

## Models in closed form

mrgsolve will solve one- and two-compartment models with first order input in
closed form. This usually results in substantial speed up. Use `$PKMODEL`.

```{r}
#| eval: false
$PKMODEL cmt = "GUT,CENT", depot = TRUE
```

Certain symbols are required to be defined depending on the model. mrgsolve
models are always parameterized in terms of clearances and volumes except for
absorption, which is in terms of rate constant.

- `CL / V`
- `CL / V / KA`
- `CL / V2 / Q / V3`
- `CL / V2 / Q / V3 / KA`

These can be defined as a parameter or a derived quantity in `$PK`.

Compartment names are user-choice; the only thing mrgsolve cares about is the 
number of compartments.

## Plugins

### autodec

Historically, you have had to _declare_ the type of any new variable you 
want to create. 

```{r}
#| eval: false
$PK
double KE = CL/V;
```

For most models, the numeric variables you declare are likely to be floating
point numbers ... with type `double`. 

We created a plugin that tells mrgsolve to look for new variables and 
declare them for you. 

```{r}
#| eval: false
$PLUGIN autodec

$PK
KE = CL/V;
```

### nm-vars


mrgsolve historically has used 

- `CENT`
- `dxdt_CENT`
- `F_CENT`
- `D_CENT`

etc. When we started mrgsolve, this was a really nice feature because you didn't
have to think about compartment _numbers_. However, this made translation of the
model more difficult.

When you invoke the `nm-vars` plugin, you can write in a syntax that is much 
more like NONMEM.

For example

```{r}
#| eval: false
$PK
F2 = THETA(3);

ALAG2 = EXP(THETA(4));

$DES
DADT(1) = - KA * A(1);
```


Other convenience syntax 

- `LOG()` and `log()`
- `LOG10()` and `log10()`
- `EXP()` and `exp()`
- `DEXP()` and `exp()`
- `SQRT()` and `sqrt()`
- `COS()` and `cos()`

Regardless of whether you have `nm-vars` invoked or not, you can still use
`THETA(n)` to refer to parameter `THETAn`.

Try the `nm-like` model in the model library for an example. 

```{r, eval = FALSE}
mod <- modlib("nm-like")

mod@code
```

### Rcpp (random numbers)

This gives you functions and data structures that you're used to using in R, 
but they work in `c++`. 

The main use for this is random number generation. Any d/q/p/r function 
in R will be available; arguments are the same, but omit `n` (you always 
get just one draw when calling from `c++`).

For a draw from U(0,1)

```{r}
#| eval: false
$PLUGIN Rcpp

$ERROR
double u = R::runif(0, 1);
```

Note: the model compilation time will slightly increase any time you invoke 
the Rcpp resources. It's still tolerable, but I just wouldn't include Rcpp if 
you don't have to.

## Other blocks

- Use `$SET` to configure the model object on load
  - For example, set the simulation end time
- Use `$ENV` to define a set of R objects that might be evaluated in other 
  model blocks
- Use `$PRED` for other user-written closed form models
- Use `$PREAMBLE` for code that gets run once at the start of a problem 
  `NEWIND==0`
- Use `$GLOBAL` to define variables outside of any other block

## Variables and macros

There is too much syntax to mention it all here. You will find all the 
syntax here

<https://mrgsolve.org/user-guide/>


## Modeled event times

To get the model to stop at any time (even if not in the data set) with 
EVID 2

```{r}
#| eval: false
double mt1 = self.mtime(1.23 + ETA(1));
```

To get the model to stop at any time with user-specified EVID (e.g. 33)

```{r}
#| eval: false
self.mevent(1.23 + ETA(1), 33);
```
